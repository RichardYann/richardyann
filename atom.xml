<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ATOM 阿瞳目</title>
  
  <subtitle>欲穷千里目，更上一层楼</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://richardyann.gitee.io/"/>
  <updated>2021-05-08T13:47:58.378Z</updated>
  <id>https://richardyann.gitee.io/</id>
  
  <author>
    <name>Richard Yann</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【实现】树莓派开机自动向微信发消息报告ip地址（无第三方代理）</title>
    <link href="https://richardyann.gitee.io/2020/11/12/%E3%80%90%E5%AE%9E%E7%8E%B0%E3%80%91%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%91%E5%BE%AE%E4%BF%A1%E5%8F%91%E6%B6%88%E6%81%AF%E6%8A%A5%E5%91%8Aip%E5%9C%B0%E5%9D%80%EF%BC%88%E6%97%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BB%A3%E7%90%86%EF%BC%89/"/>
    <id>https://richardyann.gitee.io/2020/11/12/%E3%80%90%E5%AE%9E%E7%8E%B0%E3%80%91%E6%A0%91%E8%8E%93%E6%B4%BE%E5%BC%80%E6%9C%BA%E8%87%AA%E5%8A%A8%E5%90%91%E5%BE%AE%E4%BF%A1%E5%8F%91%E6%B6%88%E6%81%AF%E6%8A%A5%E5%91%8Aip%E5%9C%B0%E5%9D%80%EF%BC%88%E6%97%A0%E7%AC%AC%E4%B8%89%E6%96%B9%E4%BB%A3%E7%90%86%EF%BC%89/</id>
    <published>2020-11-11T19:38:26.000Z</published>
    <updated>2021-05-08T13:47:58.378Z</updated>
    
    <content type="html"><![CDATA[<p>可能不少有树莓派的小伙伴都遇到过这样一个问题，长期不用但已经配置过的树莓派，刚开机会自动连接已经识别的wifi，如果没有wifi的管理密码，手头又没有可以显示的设备，手边也没有能读tf卡的机器，就只能面对默默亮灯的树莓派望洋兴叹了。</p><p>如果能在每次树莓派开机的时候自动获取连接的ip地址，并发送到自己的微信上，岂不是快捷又方便？就像这样 $↓↓↓$  ✿(。◕ᴗ◕。)✿ </p><center><img src="https://img-blog.csdnimg.cn/20201112140509489.png?x-oss-process=image" alt="在这里插入图片描述" style="zoom:67%;"/></center><p>怎么实现呢？Please follow me~ </p><hr><h3 id="1-思路（可行性分析）："><a href="#1-思路（可行性分析）：" class="headerlink" title="1. 思路（可行性分析）："></a>1. 思路（可行性分析）：</h3><ul><li>通过树莓派shell命令，可以获取ip地址</li><li>通过crontab定时任务功能，可实现开机执行特定脚本</li><li>企业微信号注册很方便，提供群发api接口，只需注册一个企业微信号，成员只有自己一个人，调用api接口可以向自己发送消息</li></ul><p>so，完全可以很方便的实现~</p><h3 id="2-获取ip地址"><a href="#2-获取ip地址" class="headerlink" title="2. 获取ip地址"></a>2. 获取ip地址</h3><p>这个应该是最简单的一步了吧，为了防止后面我忘了，就写在前面吧。<br><code>ifconfig</code>命令可以查看网络连接状态，用<code>|grep 192.168</code>筛选其中包含192.168的信息（毕竟我们只需要这个192.168.x.x的地址），再用<code>|awk -F net &#39;{print $2}&#39;</code>选择其中第一个地址，就是我们树莓派连接的ip地址了。<br>即：<code>ifconfig|grep 192.168|awk -F net &#39;{print $2}&#39;</code></p><blockquote><p><code>ifconfig</code>命令执行后包含192.168.x.x的信息应该只有两处，第一处是我们要用的ip地址inet，第二处则是broadcast。这两个信息都是在一行展示，所以用grep筛选后会是如下形式：<br><code>inet 192.168.1.4  netmask 255.255.255.0  broadcast 192.168.1.255</code><br>所以我们要再用awk的截取操作，我们发现要提取的ip地址处于两个“net”字符之间，因此我们设置截取的分隔符为“net”，则会将这段信息截成三部分，第一部分是”i”，第二部分是”192.168.1.4”，第三部分是”mask 255.255….”，我们要取的是第二部分，因此<code>print $2</code><br>&emsp;</p><ul><li>awk使用格式为：<code>|awk -F 分隔符 &#39;{命令}&#39;</code></li><li>grep使用格式为：<code>|grep 筛选内容</code></li></ul></blockquote><h3 id="3-注册企业微信号（无门槛）"><a href="#3-注册企业微信号（无门槛）" class="headerlink" title="3. 注册企业微信号（无门槛）"></a>3. 注册企业微信号（无门槛）</h3><p>点击进入→：<a href="https://work.weixin.qq.com/" target="_blank" rel="noopener">企业微信官网</a><br>按要求注册就行了，没有任何门槛，非常简单，略过不提。</p><h3 id="4-调用api发送信息"><a href="#4-调用api发送信息" class="headerlink" title="4. 调用api发送信息"></a>4. 调用api发送信息</h3><h4 id="4-1-新建应用"><a href="#4-1-新建应用" class="headerlink" title="4.1 新建应用"></a>4.1 新建应用</h4><p>在“应用管理&gt;应用&gt;自建”一栏中点击“创建应用”，根据提示创建一个应用即可。如图：</p><center><img src="https://img-blog.csdnimg.cn/20201112011817117.png?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;"/></center><h4 id="4-2-记住几个关键信息"><a href="#4-2-记住几个关键信息" class="headerlink" title="4.2 记住几个关键信息"></a>4.2 记住几个关键信息</h4><ul><li>应用ID（AgentId)</li><li>秘钥（Secret）   （以上两个均可点进刚才创建的应用列表里找到）</li><li>企业ID（corpID） （在“我的企业&gt;企业信息”最下方找到“企业ID”）</li></ul><p>然后我们在树莓派上一个方便的目录下，创建一个.sh文件，比如叫作 AutoDetectIP.sh<br>打开编辑，首行按规矩先输入：</p><pre><code class="shell">#!/bin/bash</code></pre><p>回车换行，然后我们将上述信息赋值成变量：</p><pre><code class="shell">AgentId=xxxxxSecret=xxxxxcorpId=xxxxx</code></pre><blockquote><p><strong>注1：</strong> shell赋值时等号左右不能空格！<br><strong>注2：</strong> 调用时要在变量前面加“$”，如输出AgentId：<code>echo $AgentId</code></p></blockquote><h4 id="4-3-获取access-token"><a href="#4-3-获取access-token" class="headerlink" title="4.3 获取access_token"></a>4.3 获取access_token</h4><p>需要用 get 方式请求网址，命令格式如下：<br>curl <a href="https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=ID&amp;corpsecret=SECRET" target="_blank" rel="noopener">https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=ID&amp;corpsecret=SECRET</a><br>其中ID和SECRET分别填写上面记住的企业ID和秘钥</p><blockquote><p>curl请求时，不加参数默认就是get请求，后面直接跟网址即可。</p></blockquote><p>调用前面的变量，于是命令为：<br><code>curl https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$corpId&amp;corpsecret=$Secret</code><br>如果正确，会返回一串信息，其中包含我们需要的access_token和其生效时间。<br>我们可以把这段信息赋值给一个变量temp，于是命令又进一步改为：</p><pre><code class="shell">temp=`curl https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=ID&amp;corpsecret=SECRET`</code></pre><blockquote><p>在shell脚本中反引号 ` 括起来的内容表示这是一段命令而不是字符串，也可以用$()括起来，但最好用前者。</p><ul><li><strong>注意：</strong> 要区分 $(命令) 和 ${变量}</li></ul></blockquote><p>这时temp中内容就包含了我们的access_token，接下来要截掉多与信息，依然使用前面提到的<code>|awk</code>操作：<br>观察所给信息格式，大致如下：</p><blockquote><p>如果错误，返回格式大致为：<br><code>{&quot;errcode&quot;:40001,&quot;errmsg&quot;:&quot;invalid credential, hint: [16051035.........], from ip: 111...., more info at https://open.work.weixin.qq.com/devtool/query?e=40001&quot;}</code><br>如果正确，返回格式大致为：<br><code>{&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;,&quot;access_token&quot;:&quot;.........................&quot;,&quot;expires_in&quot;:7200}</code></p></blockquote><p>我们可以将连续的双引号、冒号、双引号，即 “:” 作为分隔符，如果错误则只能得到2部分，如果正确则能得到3部分。且第三部分中如果我们再以 “,” 作为分隔符，则其中的第一部分就是纯净的access_token。因此，我们借助条件语句，代码如下：</p><pre><code class="shell">if [ -n `echo $temp|awk -F \&quot;:\&quot; &#39;{print $3}&#39;` ];then    access_token=`echo $temp|awk -F \&quot;:\&quot; &#39;{print $3}&#39;|awk -F \&quot;,\&quot; &#39;{print $1}&#39;`fi</code></pre><blockquote><ul><li>如果上述命令直接在控制台或要写成一行输入，则 fi 前面必须加分号；</li><li>if 后的判断框[ ]和里面的条件语句必须左右留有一个空格，即 [ 的右边和 ] 的左边必须空一格</li><li>参数 -n 表示如果参数长度不为0，则执行then，否则执行else（shell中如果else下没有命令就不能写，不可命令留空）；相反，参数 -z 表示如果参数长度为0，则执行then，否则执行else</li><li>双引号前面要加转义符 \ </li></ul></blockquote><p>至此，我们得到了access_token并将其存入了变量access_token中。</p><h4 id="4-4-发送信息"><a href="#4-4-发送信息" class="headerlink" title="4.4 发送信息"></a>4.4 发送信息</h4><p>需要用post方式请求网址，并用json传递结构化参数：<br><a href="https://work.weixin.qq.com/api/doc/90000/90135/90236" target="_blank" rel="noopener">官方文档</a>给出的参数示例为：</p><pre><code class="shell">{   &quot;touser&quot; : &quot;UserID1|UserID2|UserID3&quot;,   &quot;toparty&quot; : &quot;PartyID1|PartyID2&quot;,   &quot;totag&quot; : &quot;TagID1 | TagID2&quot;,   &quot;msgtype&quot; : &quot;text&quot;,   &quot;agentid&quot; : 1,   &quot;text&quot; : {       &quot;content&quot; : &quot;你的快递已到，请携带工卡前往邮件中心领取。\n出发前可查看&lt;a href=\&quot;http://work.weixin.qq.com\&quot;&gt;邮件中心视频实况&lt;/a&gt;，聪明避开排队。&quot;   },   &quot;safe&quot;:0,   &quot;enable_id_trans&quot;: 0,   &quot;enable_duplicate_check&quot;: 0,   &quot;duplicate_check_interval&quot;: 1800}</code></pre><p>post地址为：<a href="https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=ACCESS_TOKEN" target="_blank" rel="noopener">https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=ACCESS_TOKEN</a><br>（ACCESS_TOKEN为刚获取到的内容）<br>将地址赋值给变量（要不然之后的命令太长了）：</p><pre><code class="shell">PostURL=&quot;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$access_token&quot;</code></pre><p>用curl进行post请求，并以json传递参数，格式为：<br><code>curl -H &quot;Content-type: application/json&quot; -X POST -d ‘{参数}’ 网址</code></p><blockquote><p>其中，参数内容中如果要引用变量，需要先用双引号，再用单引号，再用双引号括起来，然后$变量名，例如：</p><pre><code class="shell">-X POST -d &#39;{&quot;touser&quot;:&quot;@all&quot;,&quot;msgtype&quot;:&quot;text&quot;,&quot;agentid&quot;:&quot;&#39;&quot;$AgentId&quot;&#39;&quot;,&quot;text&quot;,{&quot;content&quot;:&quot;IP地址为&#39;&quot;$IP&quot;&#39;&quot;}}&#39;</code></pre><p>参数中，msgtype、agetid、text、content是必须包含的参数，touser、toparty、totag三者至少需要包含一个<br>（IP变量没定义的记得先定义，方法如第2节所述命令，格式如前述：变量名=$`命令`  &lt;反引号括起来的都是命令&gt;）</p></blockquote><p>故发送消息命令为：</p><pre><code class="shell">curl -H &quot;Content-type: application/json&quot; -X POST -d &#39;{..如上..}&#39; $PostURL</code></pre><p>保存退出。</p><h4 id="4-5-赋予文件可执行权限并执行编写的脚本"><a href="#4-5-赋予文件可执行权限并执行编写的脚本" class="headerlink" title="4.5 赋予文件可执行权限并执行编写的脚本"></a>4.5 赋予文件可执行权限并执行编写的脚本</h4><p>赋予权限：<br><code>sudo chmod +x AutoDetectIP.sh</code></p><blockquote><p>+号代表赋予权限，-号代表剥夺权限，x表示可执行权限，r表示可读权限，w表示可写权限</p></blockquote><p>执行脚本文件：<br><code>./AutoDetectIP.sh</code></p><blockquote><p>默认用bash执行，执行时默认检查的是/etc、/bin等这些文件夹，一般我们用户操作的文件夹都不再检查范围内，所以要用 ./ 来强调从本文件夹中查找文件并执行（当然，得先进入文件夹，或者输入完整路径）</p></blockquote><p>出现如下提示且手机收到消息（需要提前扫描企业二维码关注企业，二维码在“我的企业&gt;微信插件&gt;邀请关注”中），则发送成功。</p><pre><code class="shell">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current                                 Dload  Upload   Total   Spent    Left  Speed100   277  100   277    0     0    601      0 --:--:-- --:--:-- --:--:--   602{&quot;errcode&quot;:0,&quot;errmsg&quot;:&quot;ok&quot;,&quot;invaliduser&quot;:&quot;&quot;}</code></pre><h3 id="5-设置开机自动运行"><a href="#5-设置开机自动运行" class="headerlink" title="5. 设置开机自动运行"></a>5. 设置开机自动运行</h3><p>我们使用crontab定时任务功能来实现。<br>在控制台终端输入<br><code>crontab -e</code><br>即可启动定时任务配置文件，第一次配置会提示选择编辑器，选择你习惯的编辑器或者直接回车也ok，即可进入文件进行配置，文件默认注释部分就是说明和示例，可以创建每隔多久运行一次的任务，只需按规则在文件后添加即可，且保存后如果机器重启，定时任务仍然有效。<br>格式为：</p><center><img src="https://img-blog.csdnimg.cn/20201112031651898.png?x-oss-process=image" alt="在这里插入图片描述" /></center><p>如：<br><code>0 0 * * * /home/pi/backup.sh</code>       表示每天00:00运行备份程序<br><code>*/5 * * * * python /home/pi/test.py</code>  表示每5分钟用python运行一次test.py程序<br><code>0 5 * * 1 sudo apt-get update -y; sudo apt-get upgrade -y</code>  表示每周一天05:00时更新apt软件包</p><blockquote><ul><li>星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作；</li><li>逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”；</li><li>短横（-）：可以用在整数之间表示一个范围，例如“2-6”表示“2,3,4,5,6”；</li><li>斜线（/）：可以用正斜线指定时间的间隔频率，例如h位置处填“0-10/2”表示0点到10点间每两小时执行一次。同时斜线可以和星号一起使用，例如*/10，如果用在m位置，表示每十分钟执行一次。       </li></ul></blockquote><p>如果想要每次开机执行任务，只需在文件最后添加：<br><code>@reboot /home/pi/AutoDetectIP.sh</code><br>这里面需要根据你之前创建文件的位置输入<strong>完整路径</strong>，即表示每次开机自动运行此文件</p><p>保存退出即可。</p><h3 id="6-重启自动执行不成功？"><a href="#6-重启自动执行不成功？" class="headerlink" title="6. 重启自动执行不成功？"></a>6. 重启自动执行不成功？</h3><p>到这里可以说基本已经全部完成了。可能有的小伙伴兴冲冲地重启树莓派，满心期待的望着手机，结果却发现等了个寂寞。。。<br>怎么回事呢？<br>如果检查<code>sudo service cron status</code>确定cron计时任务正在运行的话，那么主要有两个原因：</p><ol><li>系统开机时默认的环境变量和系统完全启动后用户使用的环境变量不同，因此无法执行脚本</li><li>开机时执行脚本，但当时网络还没有配置好，并不能成功获取ip并发送消息</li></ol><p>因此，针对这两种情况我们分别进行调整。</p><h4 id="6-1-添加环境变量，使cron开机能成功执行脚本"><a href="#6-1-添加环境变量，使cron开机能成功执行脚本" class="headerlink" title="6.1 添加环境变量，使cron开机能成功执行脚本"></a>6.1 添加环境变量，使cron开机能成功执行脚本</h4><p>首先我们要确定在当前用户执行成功时，脚本所用到的环境变量。<br>我们可以在脚本末尾添加一行代码：（调试成功后记得删掉）<br><code>echo $PATH</code><br>再次运行，就可以得到当前运行所使用的环境变量，比如我的为：<br><code>/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games</code><br>那么我们只需把这些环境变量手动添加到脚本中即可。<br>在脚本正文的第一行（在<code>#!/bin/bash</code>之下）添加如下代码即可：</p><pre><code class="shell">export PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games&quot;</code></pre><h4 id="6-2-添加循环判断，在未连接时不断检测，连接后发送消息"><a href="#6-2-添加循环判断，在未连接时不断检测，连接后发送消息" class="headerlink" title="6.2 添加循环判断，在未连接时不断检测，连接后发送消息"></a>6.2 添加循环判断，在未连接时不断检测，连接后发送消息</h4><p>我们使用shell脚本中的while循环语句：</p><pre><code class="shell">while true; do $(echo `ifconfig|grep 192.168`)&amp;&amp; break;sleep 1;done;</code></pre><p>如上，表示不断循环，直到匹配192.168的内容非空时，跳出循环，循环间隔1s。</p><blockquote><p>为避免多重反引号歧义，我们内外分别用$(命令)和`命令`两种形式<br>我们将此句加入脚本文件中合适位置，就可以在运行后一直等待连接网络成功的第一时间向微信发送消息。（此句至少得放在所有使用curl这样与网络相关的命令之前）</p></blockquote><p>其次，为了保证启动时程序不影响其他启动内容，或不被系统过快切断，因此我们将crontab中的命令修改为<code>nohup + 命令+ &amp;</code>这样的静默不挂起运行方式：<br>控制台输入<code>crontab -e</code>进入编辑定时任务，将原来的命令修改为：</p><pre><code class="shell">@reboot nohup /home/pi/AutoDetectIP.sh &amp;</code></pre><h3 id="7-成功！"><a href="#7-成功！" class="headerlink" title="7. 成功！"></a>7. 成功！</h3><p>至此，所有步骤都结束了。我们就可以在每次树莓派开机时，通过微信自动收到所连接的ip地址消息提示了。</p><h3 id="8-关于IP地址获取的改进"><a href="#8-关于IP地址获取的改进" class="headerlink" title="8. 关于IP地址获取的改进"></a>8. 关于IP地址获取的改进</h3><p>上面关于本机IP地址的操作主要有两个，一是通过是否包含“192.168”字段来判断是否连接wifi，二是通过<code>|grep</code>、<code>|awk</code>等操作截取纯净的ip地址信息。</p><p>其中第一个判断方式应该来说是较为准确且稳定的，符合我们的使用目标。</p><p>但第二个提取操作却有可能因为网络环境的变化，或网络设置的调整，可能会有字段的位置或是中间内容的调整，使得截取出来的不一定再是纯净的ip地址。因此我们可以更换一种更为快捷的获取IP地址的方式：</p><pre><code class="shell">hostname -I</code></pre><p>很简单的命令不用任何操作，就可以直接输出树莓派所连接的ip地址。<br>当然，如果你连接的网络给你分配了ipv6地址的话，也会一并展示出来，如果需要再按需提取即可。比如我的输出如下：</p><pre><code class="shell">pi@raspberrypi:~ $ hostname -I192.168.1.4 2409:80XXXXX（公网ip手动打码）XXXXX</code></pre><p>如果只需要提取前面的ipv4地址，那么同上用awk截取：</p><pre><code class="shell">echo `hostname -I|awk -F &#39; &#39; &#39;{print $1}&#39;`</code></pre><p>如果要赋值给变量$IP，那么用内外双重反引号会造成歧义，故可以在外面用$(命令)的方式：</p><pre><code class="bash">IP=$(echo `hostname -I|awk -F &#39; &#39; &#39;{print $1}&#39;`)</code></pre><p>如此即可提取出纯净的ipv4地址</p><hr><p>最终效果如图：</p><center><img src="https://img-blog.csdnimg.cn/20201112140303932.png?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><p>&emsp;<br>&emsp;<br>&emsp;<br>&emsp;</p><h3 id="9-附：完整示例代码："><a href="#9-附：完整示例代码：" class="headerlink" title="9.附：完整示例代码："></a>9.附：完整示例代码：</h3><pre><code class="shell">#!/bin/bash################################################      created by RichardYann     ##########            2020-11-11           ##########  EmaiL:yanrichard500@gmail.com  ################################################# set PATHexport PATH=&quot;/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/local/games:/usr/games&quot;# Global Variablescorpid=CORPID        # change to your own corpidAgentId=AGENTID        # change to your own agentidSecret=SECRET        # change to your own secretgetTokenURL=&quot;https://qyapi.weixin.qq.com/cgi-bin/gettoken?corpid=$corpid&amp;corpsecret=$Secret&quot;# check netstatwhile true; do $(echo `ifconfig|grep 192.168`)&amp;&amp; break;sleep 1;done;# get tokentemp=`curl $getTokenURL`if [ -n `echo $temp|awk -F \&quot;:\&quot; &#39;{print $3}&#39;` ];then    access_token=`echo $temp|awk -F \&quot;:\&quot; &#39;{print $3}&#39;|awk -F \&quot;,\&quot; &#39;{print $1}&#39;`fi# get postURLPostURL=&quot;https://qyapi.weixin.qq.com/cgi-bin/message/send?access_token=$access_token&quot;# get ipIP=$(echo hostname -I|awk -F &#39; &#39; &#39;{print $1}&#39;)        # change $1 to $2 if you wanna get ipv6 addr.(if you had)# send postcurl -H &quot;Content-type: application/json&quot; -X POST -d &#39;{&quot;touser&quot;:&quot;@all&quot;,&quot;msgtype&quot;:&quot;text&quot;,&quot;agentid&quot;:&quot;&#39;&quot;$AgentId&quot;&#39;&quot;,&quot;text&quot;:{&quot;content&quot;:&quot;树莓派已经启动啦！！\n\nIP地址是：&#39;&quot;$IP&quot;&#39;\n\n快点连接控制吧~~&quot;},&quot;safe&quot;:0}&#39; $PostURL</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;可能不少有树莓派的小伙伴都遇到过这样一个问题，长期不用但已经配置过的树莓派，刚开机会自动连接已经识别的wifi，如果没有wifi的管理密码，手头又没有可以显示的设备，手边也没有能读tf卡的机器，就只能面对默默亮灯的树莓派望洋兴叹了。&lt;/p&gt;
&lt;p&gt;如果能在每次树莓派开机的时
      
    
    </summary>
    
    
      <category term="瞎折腾" scheme="https://richardyann.gitee.io/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="树莓派" scheme="https://richardyann.gitee.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
  </entry>
  
  <entry>
    <title>【技巧】Edge浏览器更换chrome主题、选项卡悬浮预览（开启实验功能）</title>
    <link href="https://richardyann.gitee.io/2020/11/10/%E3%80%90%E6%8A%80%E5%B7%A7%E3%80%91Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9B%B4%E6%8D%A2chrome%E4%B8%BB%E9%A2%98%E3%80%81%E9%80%89%E9%A1%B9%E5%8D%A1%E6%82%AC%E6%B5%AE%E9%A2%84%E8%A7%88%EF%BC%88%E5%BC%80%E5%90%AF%E5%AE%9E%E9%AA%8C%E5%8A%9F%E8%83%BD%EF%BC%89/"/>
    <id>https://richardyann.gitee.io/2020/11/10/%E3%80%90%E6%8A%80%E5%B7%A7%E3%80%91Edge%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9B%B4%E6%8D%A2chrome%E4%B8%BB%E9%A2%98%E3%80%81%E9%80%89%E9%A1%B9%E5%8D%A1%E6%82%AC%E6%B5%AE%E9%A2%84%E8%A7%88%EF%BC%88%E5%BC%80%E5%90%AF%E5%AE%9E%E9%AA%8C%E5%8A%9F%E8%83%BD%EF%BC%89/</id>
    <published>2020-11-10T15:05:03.000Z</published>
    <updated>2020-11-18T17:34:28.356Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>&emsp;&emsp; 自从微软推出了新版以Chromium为核心的新版Edge浏览器，在Windows平台就成了Chrome浏览器的强大竞争对手。它有着和chrome几乎一样的功能布局和设置选项，同样支持包括谷歌商店在内的各种扩展，可以说长期使用chrome的童鞋上手没有任何不适应的感觉。</p></blockquote><blockquote><p>&emsp;&emsp;同时在中国大陆地区还有一个最突出的优点：<strong>同步方便</strong>。不必借助额外的工具，就可以<strong>在国内访问微软的扩展商店</strong>，登陆微软账户、进行同步操作。另外还有edge浏览器独有的集锦功能，在一定程度上可以替代One tab之类的扩展。因此已经有不少小伙伴将主力浏览器转移到了新版Edge上。</p></blockquote><p>&emsp;&emsp;但是，问题来了。新版Edge啥啥都好，但就是<strong>不能装主题</strong>？！微软只提供了深色、浅色两种模式，对于不少颜控来说，这一个问题就足以劝退了好吧╮(╯▽╰)╭….</p><p>&emsp;&emsp;So，如何解决这个问题呢？</p><p>&emsp;&emsp;只需<strong>开启新版Edge浏览器的实验功能</strong>即可。</p><p>&emsp;&emsp;在地址栏输入：<code>edge://flags</code> 回车即可进入“实验”选项卡，里面会有一大堆的实验功能，只需要开启“允许安装外部主题即可”（可以在页面中按关键词搜索这个选项）如下：</p><center><img src="https://img-blog.csdnimg.cn/20201110223957557.png" alt="在这里插入图片描述" style="zoom:100%;" /></center><p>&emsp;&emsp;重启浏览器后，就可以正常安装谷歌商店里的主题或者自己下载的离线主题包了。</p><hr><p>؏؏☝ᖗ乛◡乛ᖘ☝؏؏完美</p><hr><p>&emsp;&emsp;其他还有一大堆有趣的功能大家可以自行摸索，其实chrome浏览器中也是一样，在地址栏输入：<code>chrome://flags</code> 回车即可进入chrome的“实验”选项卡，里面大多数功能也和Edge是一致的，大家可以自行探索。</p><p>&emsp;&emsp;下面是我开启的几个比较好用的功能：</p><ol><li><p>允许浏览器全屏模式召唤出地址栏、收藏栏等（PC模式鼠标移动到页面顶部即出现，触屏模式在页面顶端下拉即可出现</p><center><img src="https://img-blog.csdnimg.cn/2020111716462579.png" alt="在这里插入图片描述" /></center></li><li><p>允许多线程下载以提高下载速度</p><center><img src="https://img-blog.csdnimg.cn/20201110225212929.png" alt="在这里插入图片描述" /></center></li><li><p>设置鼠标悬浮在选项卡上时以小卡片展示页面预览信息</p><center><img src="https://img-blog.csdnimg.cn/2020111022531256.png?x-oss-process=image" alt="在这里插入图片描述" /></center>（有A、B、C三种模式，发现没有任何区别，下方则是开启在悬浮卡中展示网页预览图片，如果不开下面，只开上面的功能看起来和没开好像是没有任何区别。三种模式效果均如下：）<center><img src="https://img-blog.csdnimg.cn/20201110225507998.png" alt="在这里插入图片描述" /></center></li><li><p>允许使用Backspace键来返回上一页，用shift+Backspace来转到下一页</p><center><img src="https://img-blog.csdnimg.cn/20201110225608961.png" alt="在这里插入图片描述" /></center></li><li><p>允许关闭浏览器后仍然展示浏览器的推送或通知消息（主要是一些扩展程序和网站需要弹消息。只有win10 2020年5月推出的最新2004版才可使用）</p><center><img src="https://img-blog.csdnimg.cn/20201110225740103.png" alt="在这里插入图片描述" /></center></li><li><p>允许地址栏以二维码形式分享页面链接（点击地址栏网址链接，地址栏右侧就会出现一个二维码按钮，点击会生成网址链接的二维码）</p><center><img src="https://img-blog.csdnimg.cn/20201110225914840.png" alt="在这里插入图片描述" /></center></li></ol><hr><p>暂时就先写这么多</p><p><strong>PS：有些功能你要是不明确它到底是干啥玩意儿的，最好别乱动它！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp; 自从微软推出了新版以Chromium为核心的新版Edge浏览器，在Windows平台就成了Chrome浏览器的强大竞争对手。它有着和chrome几乎一样的功能布局和设置选项，同样支持包括谷歌商店在内的各种扩展，可以说长期使
      
    
    </summary>
    
    
      <category term="瞎折腾" scheme="https://richardyann.gitee.io/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="chrome" scheme="https://richardyann.gitee.io/tags/chrome/"/>
    
      <category term="edge" scheme="https://richardyann.gitee.io/tags/edge/"/>
    
  </entry>
  
  <entry>
    <title>【你不知道的】win10“你的手机”正确打开方式：无缝连接手机电脑</title>
    <link href="https://richardyann.gitee.io/2020/05/18/%E3%80%90%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E3%80%91win10%E2%80%9C%E4%BD%A0%E7%9A%84%E6%89%8B%E6%9C%BA%E2%80%9D%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%97%A0%E7%BC%9D%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E7%94%B5%E8%84%91/"/>
    <id>https://richardyann.gitee.io/2020/05/18/%E3%80%90%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E3%80%91win10%E2%80%9C%E4%BD%A0%E7%9A%84%E6%89%8B%E6%9C%BA%E2%80%9D%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F%EF%BC%9A%E6%97%A0%E7%BC%9D%E8%BF%9E%E6%8E%A5%E6%89%8B%E6%9C%BA%E7%94%B5%E8%84%91/</id>
    <published>2020-05-18T03:37:14.000Z</published>
    <updated>2020-11-18T14:38:48.046Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;Win10系统更新后，有一项功能可能大家都曾见过，但大多都会被拒之门外。这就是“你的手机”，win10专门为连接手机和电脑推出的一项功能。不仅能让你在电脑上接收、发送手机短信，还能同步手机的各种系统通知，甚至直接在电脑上查看手机图库、接听拨打手机电话。</p><p>&emsp;&emsp;这对于经常在电脑上工作学习，有时常需要用手机接收验证码的人简直是求之不得的功能好吧Ψ(￣∀￣)Ψ</p><center><img src="https://img-blog.csdnimg.cn/20200518101646931.png?x-oss-process=image" style="zoom:80%" /></center><p>&emsp;&emsp;这项功能在以前还不是很好用，连接的方式必须在手机上下载微软自己的启动器（也就是说你手机的系统桌面都必须改变），再加上手机必须得下载微软小娜，简直不要太流氓。</p><p>&emsp;&emsp;不过现在虽然不需要这么麻烦了，但可惜的是，在中国打开后是这样的：</p><center><img src="https://img-blog.csdnimg.cn/20200518101852153.JPG?x-oss-process=image" style="zoom:80%;" /></center><p>&emsp;&emsp;怎么办呢？</p><p>&emsp;&emsp;为了能让这个让人看着眼馋的功能生效，我们需要在电脑和手机的设置中切换地区和语言。<br>&emsp;&emsp;网上有些教程只是切换地区，那还不够！是不能让这项服务正常运行的，也就是说，如果你想体验这项功能，就得强制自己面对外语（这不是又多了一个强迫自己学习的好机会嘛<del>手动滑稽</del> ）</p><blockquote><ul><li>切换地区是为了让服务启动，切换语言是为了让服务启动后内部逻辑走通（否则会网络异常连接不上手机）</li><li>手机和电脑必须都调整地区、语言设置，否则无法使用</li></ul></blockquote><p><strong>电脑设置如下：</strong><br>① 设置 &gt; 时间和语言 &gt; 区域：</p><center><img src="https://img-blog.csdnimg.cn/20200518104946893.JPG?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><p>② 设置 &gt; 时间和语言 &gt; 语言：</p><center><img src="https://img-blog.csdnimg.cn/20200518105035339.JPG?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><p><strong>手机设置如下：（以华为nova3为例）</strong></p><center><img src="https://img-blog.csdnimg.cn/20200518110614619.JPG?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><p><strong>在设置完电脑和手机的语言和区域后，只需要按照电脑上的提示一步步连接即可</strong></p><p>&emsp;&emsp;手机上需要下载 “你的手机助手” ，可以直接在谷歌商店中搜索 Your Phone Companion，这个软件下载后只有第一次连接电脑的时候需要打开，连接好后对这个app赋予最高权限、解除电源限制并设置不警告、允许自启和后台运行，随后就不需要理他了，如果还嫌不够也可以把这个app的通知关掉，这样就完全变成静默运行了。</p><p><strong>连接好后界面效果如图：</strong></p><center><img src="https://img-blog.csdnimg.cn/20200518112540676.JPG?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><p>&emsp;&emsp;这是通知界面，只要是手机上弹出的通知条，电脑上都可以同步弹出（关闭“Your Phone”窗口后会在Win10系统通知栏弹出来）</p><center><img src="https://img-blog.csdnimg.cn/20200518112726933.JPG?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><center><img src="https://img-blog.csdnimg.cn/20200518120115395.JPG?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><p>&emsp;&emsp;这是短信界面，和手机上的短信风格显示完全一样，点击进入也和手机完全一样的使用，也可以切换不同的SIM卡发送短信。未开窗口时系统弹窗是这样的，也可以直接快速回复短信：</p><center><img src="https://img-blog.csdnimg.cn/202005181133474.png?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><p>&emsp;&emsp;除此之外还可以拨号，甚至通话记录和通讯录也很好地同步：</p><center><img src="https://img-blog.csdnimg.cn/20200518113449412.JPG?x-oss-process=image" alt="在这里插入图片描述" style="zoom:80%;" /></center><p><strong>剩下还有更多精彩自行探索发现吧~~</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;Win10系统更新后，有一项功能可能大家都曾见过，但大多都会被拒之门外。这就是“你的手机”，win10专门为连接手机和电脑推出的一项功能。不仅能让你在电脑上接收、发送手机短信，还能同步手机的各种系统通知，甚至直接在电脑上查看手机图库、接听拨打手机电话
      
    
    </summary>
    
    
      <category term="瞎折腾" scheme="https://richardyann.gitee.io/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="Win10" scheme="https://richardyann.gitee.io/tags/Win10/"/>
    
  </entry>
  
  <entry>
    <title>Chrome浏览器默认全屏启动（非--kiosk模式）</title>
    <link href="https://richardyann.gitee.io/2020/05/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E5%85%A8%E5%B1%8F%E5%90%AF%E5%8A%A8%EF%BC%88%E9%9D%9E-kiosk%E6%A8%A1%E5%BC%8F%EF%BC%89/"/>
    <id>https://richardyann.gitee.io/2020/05/16/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E5%85%A8%E5%B1%8F%E5%90%AF%E5%8A%A8%EF%BC%88%E9%9D%9E-kiosk%E6%A8%A1%E5%BC%8F%EF%BC%89/</id>
    <published>2020-05-16T06:32:13.000Z</published>
    <updated>2020-05-28T02:16:22.881Z</updated>
    
    <content type="html"><![CDATA[<h4 id="十几天后更新："><a href="#十几天后更新：" class="headerlink" title="十几天后更新："></a>十几天后更新：</h4><p>&emsp;&emsp;现在又看了一遍前面的方法，真是太蠢了！！<br>&emsp;&emsp;<strong>实际上，只需要修改快捷方式的参数，只不过后面不加 –kiosk，而是在后面加 –start-fullscreen 即可！</strong> 后面的什么问题都没有了</p><p>&emsp;&emsp;也不知道之前是哪根筋儿抽了。。。</p><hr><p>&emsp;&emsp;最近捣鼓电脑的时候，觉得chrome全屏模式使用起来视觉效果很棒，再配合一些插件和快捷键，甚至不需要动鼠标，在全屏模式下就可以流畅丝滑的浏览网页<br>&emsp;&emsp;（全屏浏览用到的插件后面会提到）</p><p>&emsp;&emsp;那么作为一个懒癌晚期患者，我自然不希望每次打开chrome后还得手动全屏，或者按<code>F11</code>键全屏（F11辣么远，真累T_T）。于是网上搜了一圈，结果发现所有的办法都是在快捷方式后面加 –kiosk 参数。</p><p>&emsp;&emsp;但是这个方法有个非常严重的弊端——<strong>无法退出全屏，甚至连右键都无法使用！</strong> 这绝对是我无法忍受的！</p><p>&emsp;&emsp;因为 –kiosk参数本身是chrome自带的演示模式，用来给客户展示特定的网页，在这种情况下并不希望客户有多余的操作，但这对我们普通使用者来说就不是那么友好了，我们只是希望启动后默认全屏，正常的全屏！！</p><p>&emsp;&emsp;经过锲而不舍的尝试，我总算解决了这个问题 ↓ ↓ ↓</p><h5 id="总体思路"><a href="#总体思路" class="headerlink" title="总体思路"></a>总体思路</h5><p>利用 .bat 文件，通过命令让chrome全屏；再创建快捷方式并修改图标</p><h5 id="step-1"><a href="#step-1" class="headerlink" title="step 1"></a>step 1</h5><p>在桌面新建一个 txt 文档，打开后里面编辑：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start chrome --start-fullscreen</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>保存后命名为 chrome.bat<br>(有的电脑默认不显示扩展名，那么这样改没用，需要先显示扩展名再修改)</p><blockquote><p>注意！这里的命令基本上只能这么写，如果在 “chrome” 前不加 “start” ，那么即使后面有 “exit”，打开程序后命令行黑框也无法自动关闭；<br>如果把 “chrome” 换成 “chrome.exe”，打开后将会成为 kiosk模式</p></blockquote><h5 id="step-2"><a href="#step-2" class="headerlink" title="step 2"></a>step 2</h5><p>将 chrome.bat 文件移动到 chrome 所在的文件夹下（必须放在这里，因为上面的命令由于各种原因只能用相对地址）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200516135752797.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA2MjAxOA==,size_16,color_FFFFFF,t_70#pic_center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="step-3"><a href="#step-3" class="headerlink" title="step 3"></a>step 3</h5><p>右键 chrome.bat 建立快捷方式到桌面，并对快捷方式右键 &gt; 属性 &gt; 更改图标，找到刚才 chrome 所在文件夹，选择 chrome.exe 就会出现 chrome的图标<br>最后把快捷方式的名称一改就大功告成</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200516140501339.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA2MjAxOA==,size_16,color_FFFFFF,t_70#pic_center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h5 id="step4"><a href="#step4" class="headerlink" title="step4"></a>step4</h5><p>如果还想固定到开始菜单 or 任务栏的话，因为是自己建的快捷方式，所以需要如下操作：</p><ul><li><p>固定到开始菜单：<br>找到开始菜单的文件夹，把快捷方式放入文件夹中</p></li><li><p>固定到任务栏：<br>a) 在任意位置新建一个文件夹，把快捷方式放入其中，然后右键任务栏 &gt; 工具栏 &gt; 新建工具栏 &gt; 选择刚才新建的文件夹<br>b) 然后右键新建的工具栏（一般在任务栏右边）取消勾选 “显示文本”“显示标题”<br>c) 把新工具栏移到最左边（强行移，使劲儿移，一次移不过去，拖着它怼两下就移过去了）</p></li></ul><p>最终点击图标直接打开正常的全屏模式，效果如图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200516142956101.gif#pic_center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>至于前面说的全屏浏览插件，就两个：</p><ol><li>tabtiles ： 可以在全屏时鼠标移动到特定位置，显示标签页和地址栏，平时隐藏（还不错，就是有点丑，有了vimium说实话其实可以不要这个了）</li><li>vimium ： 可以像 vim 一样 完全用键盘进行任何操作（看着复杂，但很快就会得心应手）<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdnimg.cn/20200516141601976.JPG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjA2MjAxOA==,size_16,color_FFFFFF,t_70#pic_center" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ol><p>具体大家可以自行搜索、安装、尝试，我就不多介绍了</p><p>然后，在chrome的扩展程序中可以设置 键盘快捷键，这样连扩展程序我们也可以在全屏下使用了</p><p>最后，记一记常用的chrome快捷键（因为在某些特定页面，比如新标签页、谷歌商店、设置页面等，上面的插件不能使用），如 <code>Ctrl + W</code>关闭当前标签页，<code>Ctrl + Tab</code>切换标签页， <code>Alt + 左右键</code>前进和后退</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;十几天后更新：&quot;&gt;&lt;a href=&quot;#十几天后更新：&quot; class=&quot;headerlink&quot; title=&quot;十几天后更新：&quot;&gt;&lt;/a&gt;十几天后更新：&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;现在又看了一遍前面的方法，真是太蠢了！！&lt;br&gt;&amp;emsp;&amp;emsp;&lt;s
      
    
    </summary>
    
    
      <category term="瞎折腾" scheme="https://richardyann.gitee.io/categories/%E7%9E%8E%E6%8A%98%E8%85%BE/"/>
    
    
      <category term="chrome" scheme="https://richardyann.gitee.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>高斯混合模型GMM聚类的步骤和推导</title>
    <link href="https://richardyann.gitee.io/2020/03/20/%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8BGMM%E8%81%9A%E7%B1%BB%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%92%8C%E6%8E%A8%E5%AF%BC/"/>
    <id>https://richardyann.gitee.io/2020/03/20/%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8BGMM%E8%81%9A%E7%B1%BB%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%92%8C%E6%8E%A8%E5%AF%BC/</id>
    <published>2020-03-20T07:18:57.000Z</published>
    <updated>2020-05-28T03:15:15.492Z</updated>
    
    <content type="html"><![CDATA[<h4 id="0-引言"><a href="#0-引言" class="headerlink" title="0. 引言"></a>0. 引言</h4><p>&emsp;&emsp;由于最近要做聚类算法方面的内容，看了很多资料，在高斯混合模型(GMM)这里一直没有一个让我完全推导清楚的、理解的文章。经过<del>三天打鱼两天晒网</del> 不懈努力，总算是有一点自己的理解，我希望尽量通俗地把GMM讲明白，同时也希望尽量详细地对公式进行推导和解释。因此，我会先给出GMM算法的总体步骤，保证拿上先可以直接使用，然后再进行具体的推导和解释。文中可能有一些自己理解不严谨的地方，还请大家指正。</p><p><span id="jump1"></span></p><h4 id="1-算法初窥"><a href="#1-算法初窥" class="headerlink" title="1. 算法初窥"></a>1. 算法初窥</h4><blockquote><p>&emsp;&emsp;已知样本集是$D={x_1,x_2,…,x_m}$，要将这些样本聚成 $k$ 类。我们认为样本服从混合高斯分布：<br>$$p_M(\pmb{x})=\sum_{i=1}^k \alpha_i \cdot p(\pmb{x}|\pmb{\mu_i}, \pmb{\Sigma_i})$$<br>&emsp;&emsp;其中$p(\pmb{x}|\pmb{\mu_i}, \pmb{\Sigma_i})=\frac{1}{(2\pi)^{\frac{n}{2}}|\pmb{\Sigma_i}|^{\frac{1}{2}}}exp{-\frac{1}{2}(\pmb{x}-\pmb{\mu_i})^T\pmb{\Sigma_i}^{-1}(\pmb{x}-\pmb{\mu_i})}$是一个多元高斯分布，即一个混合成分；<br>&emsp;&emsp;$\alpha_i$表示混合系数，即选择第 $i$ 个混合成分的概率。</p></blockquote><p><strong>第一步</strong> 初始化高斯混合分布的模型参数 $\alpha_i,\pmb{\mu_i},\pmb{\Sigma_i}$<br><strong>第二步</strong> 计算$x_j$由各混合成分生成的后验概率，即观测数据$x_j$由第 $i$ 个分模型生成的概率$p(z_j=i|\pmb{x_j})$，并记为$\gamma_{ji}$<br>&emsp;&emsp;&emsp;&emsp;$\gamma_{ji}=\frac{\alpha_i\cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i})}{\sum_{l=1}^{k}\alpha_l \cdot p(\pmb{x_j}|\pmb{\mu_l},\pmb{\Sigma_l})}$<br><strong>第三步</strong> 计算新的模型参数：<br>&emsp;&emsp;&emsp;&emsp;$\pmb{\mu_i’}=\frac{\Sigma_{j=1}^m\gamma_{ji}\pmb{x_j}}{\Sigma_{j=1}^m\gamma_{ji}}$<br>&emsp;&emsp;&emsp;&emsp;$\pmb{\Sigma_i’}=\frac{\Sigma_{j=1}^m\gamma_{ji}(\pmb{x_j}-\pmb{\mu_i’})(\pmb{x_j}-\pmb{\mu_i’})^T}{\Sigma_{j=1}^m\gamma_{ji}}$<br>&emsp;&emsp;&emsp;&emsp;$\alpha_i’=\frac{\Sigma_{j=1}^m\gamma_{ji}}{m}$<br><strong>第四步</strong> 按照新的模型参数重复2，3步，直到满足停止条件<br><strong>第五步</strong> 将每个样本按照$\lambda_j=\arg\max\limits_{i\in{1,2,…,k}} \gamma_{ji}$划入对应的簇。即对每个样本来自哪个分模型的概率大就划入哪个分模型的簇中，最终就得到了 $k$ 个聚类</p><h4 id="2-高斯混合模型的引入"><a href="#2-高斯混合模型的引入" class="headerlink" title="2. 高斯混合模型的引入"></a>2. 高斯混合模型的引入</h4><p>&emsp;&emsp;与k-means聚类不同，高斯混合聚类是采用概率模型来刻画聚类结构。实际上我们可以采用任意不同的概率分布模型来进行刻画，高斯分布是最普遍的一种，如下：<br>&emsp;&emsp;<strong>高斯分布：</strong><br>$$p(\pmb{x})=\frac{1}{(2\pi)^{\frac{n}{2}}|\pmb{\Sigma}|^{\frac{1}{2}}}exp[-\frac{1}{2}(\pmb{x}-\pmb{\mu})^T\pmb{\Sigma}^{-1}(\pmb{x}-\pmb{\mu})]$$<br>&emsp;&emsp;而单高斯分布模型有其局限性，不能完全反映数据分布的特点，因此我们用多个高斯分布的线性叠加来刻画实际样本，其中一个高斯分模型称为一个混合成分。</p><blockquote><p>理论上来说，当叠加的高斯分模型数量足够多时，可以表征任意一种分布。（这其实很好理解，类比足够多微小线段可以逼近任意一条曲线、足够多复指数信号可以描述任意信号…是一样的道理）</p></blockquote><p>&emsp;&emsp;<strong>高斯混合分布：</strong><br>$$p_M(\pmb{x})=\sum_{i=1}^k \alpha_i \cdot p(\pmb{x}|\pmb{\mu_i}, \pmb{\Sigma_i})$$<br>我们认为，手里拿到的样本就是根据这个概率分布抽取得到的（或者说“生成的”）<br>例如，对于第$j$个样本$\pmb{x_j}$，就根据 $p_M(\pmb{x_j})=\sum_{i=1}^k \alpha_{ji} \cdot p(\pmb{x_j}|\pmb{\mu_i}, \pmb{\Sigma_i})$ 得到。</p><blockquote><p><strong>$\pmb{TIPS:}$</strong></p><ol><li>这里的$p(x)$、$p_M(x)$指的是概率密度函数，不是概率，在有些概率书上为了区别，用$f(x)$表示，这里都用$p(x)$表示，但心里要清楚其含义。</li><li>接上条，所以$p(\pmb{x}|\pmb{\mu_i},\pmb{\Sigma_i})$不是条件概率，而是概率密度，”$|\mu_i,\Sigma_i$”只是明确一下这个概率密度函数包含的参变量。实际上它表示的就是上面单高斯分布的$p(x)$。</li><li>$\pmb{x}$是一条样本，但是有$n$个维度，因此是一个$n$维向量。</li><li>$\alpha_i&gt;0$是在生成这条样本时，选择通过第$i$个分模型来生成的概率，且$\sum_{i=1}^k\alpha_i=1$。（不能说成”样本来自第$i$个分模型的概率”，因为这里是一个先验的情况，如果这样说就成了后验了）</li><li>$\pmb{\mu}_i,\pmb{\Sigma}_i$是第$i$个分模型的参数。其中，$\pmb{\mu}_i$表示均值，是一个$n$维向量，$\pmb{\Sigma}_i$表示协方差矩阵，是一个$n×n$方阵。</li></ol></blockquote><p><span id="jump3"></span></p><h4 id="3-按照高斯混合模型进行聚类划分"><a href="#3-按照高斯混合模型进行聚类划分" class="headerlink" title="3. 按照高斯混合模型进行聚类划分"></a>3. 按照高斯混合模型进行聚类划分</h4><p>&emsp;&emsp;上面说了我们认为手里拿到的样本就是通过高斯混合模型抽取得到的，那么反过来我们要怎么把这些样本用高斯混合模型划分成不同的类别呢？<br>&emsp;&emsp;一个很直接的想法自然是按照模型的混合成分划成 $k$ 类，一个数据最可能从哪个分模型得来就认为属于哪一类。<br>&emsp;&emsp;在这里，我们要引入一个隐变量 $z_j\in{1,2,…,k}$ 表示得到样本 $\pmb{x_j}$的高斯分模型。</p><blockquote><p>注：</p><ol><li>有的书上用一维向量来表示，即若认为样本$\pmb{x_j}$来自第2个高斯分模型，则$z_j=[0,1,0,0,…,0]$。 这里直接用数字来表示来自第几个分模型。</li><li>根据$z_j$的含义很容易看出，$P(z_j=i)$表示$\pmb{x_j}$是通过第$i$个分模型生成的概率，就是高斯混合模型中的参数$\alpha_{ji}$</li></ol></blockquote><p>&emsp;&emsp;前面我们说了，$\alpha$是一个先验概念，是从模型到样本的过程。而现在我们在已经拿到了样本的情况下反推其来自哪个分模型，是逆向过程，因此我们用$p_M(z_j=i|\pmb{x_j})$来表示样本$\pmb{x_j}$来自第$i$个分模型的后验概率，并简记为$\gamma_{ji}$。有：<br>$$p_M(z_j=i|\pmb{x_j})=\frac{P(z_j=i)\cdot p_M(\pmb{x_j}|z_j=i)}{p_M(\pmb{x_j})} \\ =\frac{\alpha_i\cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i})}{\sum_{l=1}^{k}\alpha_l \cdot p(\pmb{x_j}|\pmb{\mu_l},\pmb{\Sigma_l})}$$</p><blockquote><p>注：</p><ol><li>$p_M(\pmb{x_j}|z_j=i)$表示按照第$i$个高斯分模型生成$\pmb{x_j}$的概率密度，第$i$个高斯分模型的参数是$\pmb{\mu_i},\pmb{\Sigma_i}$，故而就等于$p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i})$</li><li>$p_M(\pmb{x_j})$表示综合所有的混合成分后总的概率密度</li><li>上述等式第一行由贝叶斯公式得到<br>&emsp;贝叶斯公式： $p(A|B)=\frac{p(A)p(B|A)}{p(B)}$</li></ol></blockquote><p>那么显而易见地，每个样本$\pmb{x_j}$的簇标记$\lambda_j$如下确定：<br>$$\lambda_j=\arg\max_{i \in {1,2,…,k}}\gamma_{ji}$$<br>即，$\pmb{x_j}$来自哪个分模型的概率最大，就认为属于哪一类。</p><h4 id="4-确定高斯混合模型参数"><a href="#4-确定高斯混合模型参数" class="headerlink" title="4. 确定高斯混合模型参数"></a>4. 确定高斯混合模型参数</h4><p>&emsp;&emsp;上面已经说了当已知高斯混合模型时，就可以进行聚类的划分，那么如何求解这个模型，得到它的三个参数呢？<br>&emsp;&emsp;我们在这里要用到的是EM算法（期望最大算法）。其实原理很简单：为什么我们能拿到手中的样本，而不是其他数据呢？我们认为这是由于选出这样一组样本的概率最大，所以才运气爆表，被我们拿到手。<br>&emsp;&emsp;由上文知，按照高斯混合模型选出一个样本$\pmb{x_j}$的概率密度<br>$$p_M(\pmb{x_j})=\sum_{i=1}^k\alpha_i \cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i})$$<br>&emsp;&emsp;对于手中的$m$个样本，选到任意一个都是一个独立事件，最终的概率自然是全部相乘，即<br>$$\prod_{j=1}^mp_M(\pmb{x_j})$$<br>但是，连乘不好处理，因此一般习惯对它取对数，于是样本集$D$的最大化对数似然函数就定义如下：<br>$$LL(D)=\ln(\prod_{j=1}^mp_M(\pmb{x_j}))<br>\\ =\sum_{j=1}^m \ln(p_M(\pmb{x_j}))<br>\\ =\sum_{j=1}^m \ln(\sum_{i=1}^k \alpha_i \cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i}))$$<br>&emsp;&emsp;只要能求出使$LL(D)$最大的参数就可以了。<br>&emsp;&emsp;那么怎么求满足要求的参数呢？<br>&emsp;&emsp;我们设参数$\theta_i={(\alpha_i,\mu_i,\Sigma_i)}$能使$LL(D)$最大化，那么$LL(D)$对每个参数的偏导数应该为0，但是偏导数为0求出的参数有可能只是局部最优解（$LL(D)$取极大值或驻点），而不是全局最优解（$LL(D)$取最大值）。<br>&emsp;&emsp;经过后面的推导，我们可以发现求出的每个参数，都可以用$\gamma_{ji}$表示。所以，我们在求出了一组模型参数后，按照这种模型得到对应的$\gamma_{ji}$，再用得到的$\gamma_{ji}$继续按照偏导数为0的方式求出新的参数。如此循环迭代，直到我们认为足够为止。</p><blockquote><p>至于为什么每次迭代都可以使求得的参数更优，这个问题就不在本文展开叙述了，具体可以参考EM算法的相关资料。有时间我会专门写一篇关于EM算法的文章。</p></blockquote><p>&emsp;&emsp;<strong>现在我们来具体求解每个参数：</strong></p><h5 id="①-pmb-mu"><a href="#①-pmb-mu" class="headerlink" title="① $\pmb{\mu}:$"></a>① $\pmb{\mu}:$</h5><p>$$\frac{\partial LL(D)}{\partial \pmb{\mu_i}}=0<br>\\  → \frac{\partial}{\partial \pmb{\mu_i}}\sum_{j=1}^m \ln (\sum_{i=1}^k \alpha_i \cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i}))=0<br>\\  → \sum_{j=1}^m\frac{1}{\sum_{l=1}^k \alpha_l \cdot p(\pmb{x_j}|\pmb{\mu_l},\pmb{\Sigma_l})} \cdot \frac{\partial}{\partial \pmb{\mu_i}}[\sum_{l=1}^k\alpha_l \cdot p(\pmb{x_j}|\pmb{\mu_l},\pmb{\Sigma_l})]=0$$<br>&emsp;&emsp;(这里因为对$\pmb{\mu_i}$求偏导，为了避免混淆，将求和变量写成 $l$)<br>&emsp;&emsp;对$\frac{\partial}{\partial \pmb{\mu_i}}[\sum_{l=1}^k\alpha_l \cdot p(\pmb{x_j}|\pmb{\mu_l},\pmb{\Sigma_l})]$来说，只有当 $l=i$时，包含$\mu_i$的内容，其余对$\mu_i$求偏导均为0，可以舍去，则继续推导如下：<br>$$→ \sum_{j=1}^m\frac{1}{\sum_{l=1}^k \alpha_l \cdot p(\pmb{x_j}|\pmb{\mu_l},\pmb{\Sigma_l})} \cdot \frac{\partial}{\partial \pmb{\mu_i}}[ \alpha_i \cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i})]=0$$<br>&emsp;&emsp;其中，<br>$$\frac{\partial}{\partial \pmb{\mu_i}}[ \alpha_i \cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i})]<br>\\ =\frac{\partial}{\partial \pmb{\mu_i}}{\alpha_i\frac{1}{(2\pi)^{\frac{n}{2}}|\pmb{\Sigma_i}|} \exp[-\frac{1}{2}(\pmb{x_j}-\pmb{\mu_i})^T\pmb{\Sigma_i}^{-1}(\pmb{x_j}-\pmb{\mu_i})]}<br>\\ =\alpha_i\frac{\exp[-\frac{1}{2}(\pmb{x_j}-\pmb{\mu_i})^T\pmb{\Sigma_i}^{-1}(\pmb{x_j}-\pmb{\mu_i})]}{(2\pi)^{\frac{n}{2}}|\pmb{\Sigma_i}|} \frac{\partial}{\partial\pmb{\mu_i}}[-\frac{1}{2}(\pmb{x_j}-\pmb{\mu_i})^T\pmb{\Sigma_i}^{-1}(\pmb{x_j}-\pmb{\mu_i})]<br>\\ =\alpha_i\cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i})\cdot(\pmb{x_j}-\pmb{\mu_i})<br>$$</p><blockquote><p>这里是向量/矩阵对另一个向量求导，不是标量求导，具体可以参考矩阵求导相关资料</p></blockquote><p>&emsp;&emsp;因此继续推导如下：<br>$$→ \sum_{j=1}^m\frac{\alpha_i \cdot p(\pmb{x_j}|\pmb{\mu_i},\pmb{\Sigma_i})}{\sum_{l=1}^k \alpha_l \cdot p(\pmb{x_j}|\pmb{\mu_l},\pmb{\Sigma_l})} (\pmb{x_j}-\pmb{\mu_i})=0<br>\\ → \sum_{j=1}^m p_M(z_j=i|\pmb{x_j})(\pmb{x_j}-\pmb{\mu_i})=0<br>\\ → \sum_{j=1}^m \gamma_{ji}\cdot (\pmb{x_j}-\pmb{\mu_i})=0<br>\\ → \sum_{j=1}^m \gamma_{ji}\pmb{x_j}=\sum_{j=1}^m\gamma_{ji}\pmb{\mu_i}<br>\\ → \pmb{\mu_i}=\frac{\sum_{j=1}^m \gamma_{ji}\pmb{x_j}}{\sum_{j=1}^m\gamma_{ji}}$$</p><p>&emsp;&emsp;至此，参数$\pmb{\mu_i}$迭代公式得到。</p><h5 id="②-pmb-Sigma"><a href="#②-pmb-Sigma" class="headerlink" title="② $\pmb{\Sigma}:$"></a>② $\pmb{\Sigma}:$</h5><p>&emsp;&emsp;同理，由<br>$$\frac{\partial LL(D)}{\partial \pmb{\Sigma_i}}=0$$<br>&emsp;&emsp;推得：<br>$$\pmb{\Sigma_i}=\frac{\sum_{j=1}^m\gamma_{ji}(\pmb{x_j}-\pmb{\mu_i})(\pmb{x_j}-\pmb{\mu_i})^T}{\sum_{j=1}^m\gamma_{ji}}$$</p><h5 id="③-alpha"><a href="#③-alpha" class="headerlink" title="③ $\alpha:$"></a>③ $\alpha:$</h5><p>&emsp;&emsp;求$\alpha$的过程略有不同，因为除了要使$LL(D)$最大化以外，$\alpha$还要满足它自身的条件：$\alpha_i ≥0,\sum_{i=1}^k\alpha_i=1$。<br>&emsp;&emsp;这是一个有条件的极值问题，我们要用拉格朗日乘数法来求解（具体可以参考拉格朗日乘数法求极值的相关资料）<br>&emsp;&emsp;相当于将$LL(D)$求极值问题转化为$LL(D)+\lambda(\sum_{i=1}^k\alpha_i -1)$求极值的问题，然后依然对$\alpha_i$求导为0，由此得到：<br>$$\alpha_i=\frac{1}{m}\sum_{j=1}^m\gamma_{ji}$$</p><p>&emsp;&emsp;至此，高斯混合模型聚类的所有参数公式均已得到，下来只要不断迭代，并按照文章<a href="#jump3">第3节</a>中的划分方式来进行聚类划分即可。</p><p>&emsp;&emsp;最后，可以再回头看看文章<a href="#jump1">第1节</a>的算法总结。</p><hr><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol><li>周志华，机器学习，清华大学出版社，2016</li><li>李航，统计学习方法，清华大学出版社，2012</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;0-引言&quot;&gt;&lt;a href=&quot;#0-引言&quot; class=&quot;headerlink&quot; title=&quot;0. 引言&quot;&gt;&lt;/a&gt;0. 引言&lt;/h4&gt;&lt;p&gt;&amp;emsp;&amp;emsp;由于最近要做聚类算法方面的内容，看了很多资料，在高斯混合模型(GMM)这里一直没有一个让我完全推
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://richardyann.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://richardyann.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="大数据" scheme="https://richardyann.gitee.io/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="数据分析" scheme="https://richardyann.gitee.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="聚类" scheme="https://richardyann.gitee.io/tags/%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>PCA降维的数学理解与举例</title>
    <link href="https://richardyann.gitee.io/2020/02/16/PCA%E9%99%8D%E7%BB%B4%E7%9A%84%E6%95%B0%E5%AD%A6%E7%90%86%E8%A7%A3%E4%B8%8E%E4%B8%BE%E4%BE%8B/"/>
    <id>https://richardyann.gitee.io/2020/02/16/PCA%E9%99%8D%E7%BB%B4%E7%9A%84%E6%95%B0%E5%AD%A6%E7%90%86%E8%A7%A3%E4%B8%8E%E4%B8%BE%E4%BE%8B/</id>
    <published>2020-02-16T15:58:39.000Z</published>
    <updated>2020-05-28T01:23:37.331Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>PCA(Principle Component Analysis 主成分分析)是深度学习中最常用的降维算法。本文将通过最基础的线性代数知识对PCA算法进行解释。</p></blockquote><h4 id="0-为什么要进行降维-amp-降维的目标-amp-降维的原则"><a href="#0-为什么要进行降维-amp-降维的目标-amp-降维的原则" class="headerlink" title="0. 为什么要进行降维&amp;降维的目标&amp;降维的原则"></a>0. 为什么要进行降维&amp;降维的目标&amp;降维的原则</h4><h5 id="0-1-为什么要进行降维"><a href="#0-1-为什么要进行降维" class="headerlink" title="0.1 为什么要进行降维"></a>0.1 为什么要进行降维</h5><p>在深度学习中，需要对大量的样本数据进行处理，而每个样本会包含很多特征（即维度），这样在进行各种运算和训练时无疑会消耗大量的内存和时间，所以我们希望适当的减少每个样本的维度，从而简化运算。</p><h5 id="0-2-降维的目标"><a href="#0-2-降维的目标" class="headerlink" title="0.2 降维的目标"></a>0.2 降维的目标</h5><p>假设原始的数据集为$X_{m×n}$，如下所示：<br>$$X_{m×n}=\left[<br>\begin{matrix}<br>x_1^{(1)}&amp;x_2^{(1)}&amp;\dots &amp; x_n^{(1)} \\ x_1^{(2)}&amp;x_2^{(2)}&amp;\dots &amp; x_n^{(2)} \\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots \\ x_1^{(m)}&amp; x_2^{(m)}&amp;\dots &amp; x_n^{(m)}<br>\end{matrix}<br>\right]$$<br>表示有m个样本数据，每个样本数据有n个维度。即上述矩阵每一行是一个样本，共m个样本；每一列是一个维度，共n个维度。</p><p>我们的目标是不改变样本数量，减少样本维度，即减少上述矩阵的列数。</p><p>假设降成k维，则最终得到的降维后数据集为：<br>$$Y_{m×k}=\left[<br>\begin{matrix}<br>y_1^{(1)}&amp;y_2^{(1)}&amp;\dots &amp; y_k^{(1)}\\ y_1^{(2)}&amp;y_2^{(2)}&amp;\dots &amp; y_k^{(2)}\\ \vdots&amp;\vdots&amp;\ddots&amp;\vdots\\ y_1^{(m)}&amp;y_2^{(m)}&amp;\dots &amp; y_k^{(m)}<br>\end{matrix}<br>\right]$$</p><p>设$Y_{m×k}=X_{m×n}Q_{n×k}$，<strong>我们只要求出Q，就可以把X降维成Y，因此我们的目标就是找出一个恰当的Q</strong></p><h5 id="0-3-降维的原则"><a href="#0-3-降维的原则" class="headerlink" title="0.3 降维的原则"></a>0.3 降维的原则</h5><p>我们要在降低维度时尽可能减少数据的损失，所以我们让<strong>不同维度之间尽可能接近，同一维度的不同数据尽可能分散</strong>。（不同维度之间越接近，就意味着去掉一些维度时损失较小；同一维度的不同数据越分散，就意味着在这一维度上的数据越容易被区分）</p><p>我们在协方差矩阵中来衡量这一接近、分散程度。</p><blockquote><p>以m个3维数据为例：（<em>注意：a,b,c 表示不同维度，每一行是一个样本，每一列是一个维度</em>）<br>$$\left[\begin{matrix}<br>a_1&amp;b_1&amp;c_1\\ a_2&amp;b_2&amp;c_2\\ \vdots&amp;\vdots&amp;\vdots\\ a_m&amp;b_m&amp;c_m<br>\end{matrix}\right]$$<br>其协方差为：<br>$$cov=\left[\begin{matrix}<br>cov(a,a)&amp;cov(a,b)&amp;cov(a,c)\\ cov(b,a)&amp;cov(b,b)&amp;cov(b,c)\\ cov(c,a)&amp;cov(c,b)&amp;cov(c,c)<br>\end{matrix}\right]$$<br>容易看出在协方差矩阵中，对角线元素表示的是每个维度上样本的方差，而非对角线元素表示的是不同维度之间样本的协方差。要使得“不同维度之间尽可能接近，同一维度数据尽可能分散”，就要让<strong>非对角线元素尽可能小，对角线元素尽可能大</strong>。</p></blockquote><p>我们通过对数据的处理，使其协方差矩阵成为一个对角阵，那么非对角线元素为0，我们就可以放心的删去多余的维度；在删去时，我们删掉较小的对角线元素对应的列。</p><h4 id="1-计算X，Y的协方差矩阵"><a href="#1-计算X，Y的协方差矩阵" class="headerlink" title="1. 计算X，Y的协方差矩阵"></a>1. 计算X，Y的协方差矩阵</h4><p>对于原始数据集$X_{m×n}$，其协方差矩阵为：<br>$$Cx_{n×n}=\frac{1}{m}X^TX$$（概率论里除以m-1的公式是无偏估计，但是这里数据总数已知，不涉及估计问题，只涉及离散程度的描述，因此除以m）</p><p>我们设最终数据集$Y_{m×k}=X_{m×n}Q_{n×k}$，则其协方差矩阵满足：<br>$$Cy_{k×k}=\frac{1}{m}Y^TY \\ =\frac{1}{m}Q^TX^TXQ \\ =Q^TCxQ$$</p><h4 id="2-对角化"><a href="#2-对角化" class="headerlink" title="2. 对角化"></a>2. 对角化</h4><p>在降维之前，我们要处理数据集使其协方差矩阵成为对角阵，（即数据集要经过两步处理，X→ Y’ →Y），设 $Y’_{m×n}=X_{m×n}Q’_{n×n}$<br>则同理可得 $Y’$ 的协方差矩阵为：  </p><p>$$Cy’_{k×k} = \frac{1}{m}Y’^TY’ \\ =\frac{1}{m}Q’^TX^TXQ’ \\ =Q’^TCxQ’$$</p><p>对 $Cx$，有 $Cx=P\Lambda P^{T}$</p><blockquote><p>设$Cx$特征值为：$\lambda_1, \lambda_2, \dots, \lambda_n$（$\lambda_1 ≥\lambda_2≥\dots≥\lambda_n$）<br>对应特征向量为：$\xi_1, \xi_2, \dots, \xi_n$<br>则令$P=[\xi_1,\xi_2,\dots, \xi_n]$，有$Cx=P\Lambda P^{-1}$<br>其中，$\Lambda=diag[\lambda_1, \lambda_2, \dots, \lambda_n]$，是一个由特征值构成的对角阵<br>由于协方差矩阵一定是对称阵，根据对称阵的性质，不同特征值对应的特征向量正交，即$P^TP=I=P^{-1}P$，即$P^T=P^{-1}$<br>故有$Cx=P\Lambda P^T$</p></blockquote><p>因此我们令$Q’=P$，则有：<br>$$Cy’=Q’^TCxQ’ \\ =P^TP\Lambda P^TP \\ =\Lambda=diag[\lambda_1 \lambda_2 \dots \lambda_n]$$</p><p>这样我们就将协方差矩阵转成了对角阵，实现这一变化的矩阵$Q’=P$。</p><h4 id="3-降维"><a href="#3-降维" class="headerlink" title="3. 降维"></a>3. 降维</h4><p>假设降低成k维，由于之前已经将特征值从大到小排序，所以取前k个特征值$\lambda$对应的特征向量$\xi$构成$Q$:<br>$$Q=[\xi_1,\xi_2,\dots,\xi_k]$$<br>这样得到最终数据集$Y$的协方差矩阵：<br>$$Cy=Q^TCxQ \\ =diag[\lambda_1 \dots \lambda_k] \\ (\lambda_i是n维列向量)$$<br>则$Y=XQ$，实现了从$X_{m×n}$到$Y_{m×k}$的降维。</p><h4 id="4-举例"><a href="#4-举例" class="headerlink" title="4. 举例"></a>4. 举例</h4><p>若给定原始数据集为<br>$$X=\left[\begin{matrix}<br>1&amp;-1&amp;3&amp;2&amp;0 \\ -2&amp;0&amp;4&amp;1&amp;1<br>\end{matrix}\right]$$<br>则其协方差矩阵为<br>$$Cx=\frac{1}{2}X^TX \\ =\left[\begin{matrix}<br>2.5&amp;-0.5&amp;-2.5&amp;0&amp;-1 \\ -0.5&amp;0.5&amp;-1.5&amp;-1&amp;0 \\ -2.5&amp;-1.5&amp;12.5&amp;5&amp;2 \\ 0&amp;-1&amp;5&amp;2.5&amp;0.5 \\ -1&amp;0&amp;2&amp;0.5&amp;0.5<br>\end{matrix}\right]$$<br>其特征值为：$\lambda_1=15.5,\lambda_2=3,\lambda_{3,4,5}≈0$<br>对应特征向量$\xi_1$~$\xi_5$构成矩阵$P$为：<br>$$P=[\begin{matrix}\xi_1&amp;\xi_2&amp;\xi_3&amp;\xi_4&amp;\xi_5]\end{matrix} \\ =\left[\begin{matrix}<br>-0.18&amp;-0.82&amp;-0.29&amp;0.38&amp;0.27 \\ -0.11&amp;0.33&amp;0.11&amp;0.90&amp;-0.23 \\ 0.90&amp; 0  &amp;-0.41&amp;0.15&amp;-0.05 \\ 0.36 &amp;  -0.41 &amp;  0.82  &amp; 0.04&amp; -0.18 \\ 0.14 &amp;   0.24 &amp;  0.25&amp;  0.13 &amp;   0.92<br>\end{matrix}\right]$$<br>观察特征值，我们很容易发现后面三个非常小接近0，故而可以忽略，所以我们把原来的5维降低成2维是合理的，那么我们只需取最大的两个特征值对应的特征向量来构成$Q$：<br>$$Q=[\begin{matrix}\xi_1&amp;\xi_2]\end{matrix} \\ =\left[\begin{matrix}<br>-0.18&amp;-0.82 \\ -0.11&amp;0.33 \\ 0.90&amp; 0 \\ 0.36 &amp;  -0.41 \\ 0.14 &amp;   0.24<br>\end{matrix}\right]$$<br>则得到降维后的数据集$Y:$<br>$$Y=XQ \\ =\left[\begin{matrix}<br>3.34&amp;-1.96 \\ 4.45&amp;1.47<br>\end{matrix}\right]$$</p><p>通常情况下，用PCA降维的同时还伴随着数据中心化，即使得所有数据点的中心归一到坐标原点。为与普遍的算法结果保持一致，我们对上述降维后的数据集进行中心化，即每一列减去该列的均值，得到：<br>$$Y_{中心化}=\left[\begin{matrix}<br>-0.56&amp;-1.71 \\ 0.56&amp;1.71<br>\end{matrix}\right]$$</p><blockquote><h4 id="在使用PCA时注意："><a href="#在使用PCA时注意：" class="headerlink" title="在使用PCA时注意："></a>在使用PCA时注意：</h4><ul><li>一定要弄清楚数据集的行、列，哪个是样本数，哪个是特征数（维度）</li><li>若数据集以行表示维度，列表示样本数（即与本文相反），那么协方差矩阵一定不能用自带的函数计算，其计算公式改为$Cx=\frac{1}{m}XX^T$, 其他的将相应的列操作变成行操作即可。不过与其如此，不如直接把原始数据集转置。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;PCA(Principle Component Analysis 主成分分析)是深度学习中最常用的降维算法。本文将通过最基础的线性代数知识对PCA算法进行解释。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;0-为什么要进行降维-amp-降维
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://richardyann.gitee.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://richardyann.gitee.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="降维" scheme="https://richardyann.gitee.io/tags/%E9%99%8D%E7%BB%B4/"/>
    
  </entry>
  
</feed>
